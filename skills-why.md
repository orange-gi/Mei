# Anthropic Skills 提示词分析

## 一、提示词位置与结构

### 1.1 技能文件定位

Anthropic Skills 项目中的提示词主要分布在两个层级：技能模板层和具体技能实现层。技能模板位于仓库的 template 目录，提供了创建新技能的标准框架；具体技能实现位于 skills 目录，包含创意设计、开发技术、企业通信和文档处理等四大类别的示例技能。每个技能的提示词都封装在对应的 SKILL.md 文件中，这种集中式的提示词管理方式便于维护、版本控制和复用。

技能文件的目录结构遵循标准化设计规范。以 DOCX 技能为例，其完整结构包含 SKILL.md 核心指令文件、docx-js.md JavaScript 文档创建指南、ooxml.md Python XML 操作手册，以及 ooxml/scripts/ 目录下的解包和打包脚本。这种分层设计将指令性提示词与参考性文档分离，既保证了核心提示词的简洁性，又为复杂操作提供了详细的实现指南。

### 1.2 YAML 前置元数据设计

每个 SKILL.md 文件都以 YAML 格式的前置元数据（frontmatter）开头，这是技能识别的关键入口点。元数据包含 name 和 description 两个必需字段，这两个字段构成了技能匹配和激活的基础。以文档处理技能为例，其前置元数据设计如下：

```yaml
---
name: docx
description: Comprehensive document creation, editing, and analysis with support for tracked changes, comments, formatting preservation, and text extraction. When Claude needs to work with professional documents (.docx files) for: (1) Creating new documents, (2) Modifying or editing content, (3) Working with tracked changes, (4) Adding comments, or any other document tasks
---
```

description 字段的设计尤为精妙，它不仅描述了技能功能，还明确列出了适用场景的编号列表。这种设计使得 Claude 能够精确判断何时应该激活该技能，避免了因描述模糊导致的技能误匹配问题。编号列表的形式也为后续可能的场景扩展预留了空间，体现了良好的前瞻性设计思维。

### 1.3 技能文件目录分布

仓库中的技能目录按照功能领域进行组织，形成清晰的分类体系：

```
skills/
├── creative/                    # 创意与设计类技能
│   ├── art/
│   ├── music/
│   └── design/
├── development/                 # 开发与技术类技能
│   ├── testing/
│   ├── mcp-server/
│   └── code-review/
├── enterprise/                  # 企业与通信类技能
│   ├── branding/
│   └── communications/
└── document/                    # 文档处理类技能
    ├── docx/
    ├── pdf/
    ├── pptx/
    └── xlsx/
```

文档处理类技能是项目中最复杂的技能集，包含 DOCX、PDF、PPTX 和 XLSX 四种格式的创建和编辑能力。这些技能共享相似的结构设计模式，但针对各自的格式特点提供了专门的指令和工具。

## 二、核心提示词内容分析

### 2.1 DOCX 技能核心指令

DOCX 技能的 SKILL.md 文件是整个项目中指令设计最完善的示例之一。其核心指令按照任务类型进行组织，形成了一个完整的「决策树」结构，帮助 Claude 在不同场景下选择正确的工作流程。指令开篇即定义了一个清晰的工作流决策框架，将任务分为「读取与分析」「创建新文档」「编辑现有文档」三大类别，每一类别下又细分为具体的操作路径。

对于「读取与分析」场景，技能提供了两种获取文档内容的方法：文本提取和原始 XML 访问。文本提取使用 pandoc 工具将文档转换为 Markdown 格式，适合只需要获取文本内容的场景；原始 XML 访问则通过解压 DOCX 文件（本质是 ZIP 压缩包）直接读取 XML 内容，适用于需要处理评论、复杂格式、嵌入媒体等高级场景。

对于「创建新文档」场景，技能指令 Claude 使用 docx-js 库进行 JavaScript/TypeScript 方式的文档创建。指令中特别强调了MANDATORY（强制）要求：在开始创建之前必须完整阅读 docx-js.md 参考文档（约 500 行），且禁止设置范围限制读取。这种设计确保了 Claude 在执行文档创建前已经掌握了必要的格式细节。

对于「编辑现有文档」场景，技能区分了「自己的文档简单修改」「他人文档」和「法律/学术/商业/政府文档」三种情况。对于他人文档和法律文档，明确要求使用「修订追踪工作流」（redlining workflow），这是专业文档编辑的最佳实践。修订追踪工作流的设计体现了对专业文档处理流程的深刻理解，它要求将所有更改以追踪修订的形式呈现，便于审阅和批准。

### 2.2 修订追踪工作流指令

修订追踪（Redlining）工作流是 DOCX 技能中最复杂也最专业的部分，其指令设计堪称提示词工程的典范。工作流的核心原则被浓缩为一句话：「最小化、精确编辑」。这个原则指导所有修订操作的实施，要求只标记真正发生变更的文本，避免重复未变更内容导致的混乱。

指令中提供了具体的代码模式对比，直观展示了正确和错误的实现方式：

```markdown
# 错误的做法 - 替换整个句子
'The term is 30 days.The term is 60 days.'

# 正确的做法 - 只标记变更部分，保留原始 <w:r> 用于未变更文本
'The term is <w:del>30</w:del><w:ins>60</w:ins> days.'
```

这种对比式的指令展示方式比纯文字描述更加有效，Claude 能够直接理解预期输出与错误输出的区别。

工作流还引入了「批次策略」（Batching Strategy）的概念，将大量变更分组为 3-10 个变更的小批次。这种设计考虑了实际工作中的可管理性——大数量的变更容易出错且难以调试，而小批次操作允许增量式推进和验证。指令中详细描述了批次组织的方式：可以按文档章节、按变更类型、按复杂程度或按页面顺序进行分组。

### 2.3 文档转图像工作流

DOCX 技能中还包含了一个实用但常被忽视的功能：将文档转换为图像进行可视化分析。这个工作流虽然不属于核心文档处理功能，但在需要查看文档渲染效果或进行视觉验证时非常有用。

工作流采用两步转换策略：首先使用 LibreOffice 将 DOCX 转换为 PDF，然后使用 pdftoppm 工具将 PDF 页面转换为 JPEG 图像。指令中详细列出了各工具的参数选项和使用示例：

```bash
# DOCX 转 PDF
soffice --headless --convert-to pdf document.docx

# PDF 转图像（150 DPI，分辨率可调整）
pdftoppm -jpeg -r 150 document.pdf page

# 指定页面范围的转换示例
pdftoppm -jpeg -r 150 -f 2 -l 5 document.pdf page
```

这种分步转换的方法虽然增加了操作步骤，但每个步骤的工具选择都是最优的：LibreOffice 对 Office 格式的支持最为全面，pdftoppm 提供了灵活的分辨率和格式选项。指令的设计考虑到了工具链的可用性，同时也为用户提供了根据需要调整参数的能力。

### 2.4 代码风格指南

在技能指令的末尾，通常会包含针对生成代码的风格要求。DOCX 技能中的代码风格指南简短但明确：

```markdown
**IMPORTANT**: When generating code for DOCX operations:
- Write concise code
- Avoid verbose variable names and redundant operations
- Avoid unnecessary print statements
```

这三条规则针对的是 AI 生成代码常见的问题：冗余和过度详细。简洁的代码不仅更易于阅读和维护，也减少了引入错误的机会。避免不必要的 print 语句是因为在生产环境中，这些调试输出通常需要被移除，预先避免可以减少后续清理工作。

## 三、提示词设计模式

### 3.1 决策树模式

DOCX 技能采用了清晰的决策树（Decision Tree）结构来组织指令。决策树从任务目标出发，通过一系列二元选择逐步缩小到具体的执行路径。这种模式特别适合处理具有多种可能操作的任务类型，它帮助 Claude 在面对复杂场景时做出正确决策。

决策树的设计遵循「先分类后细分」的原则：首先将任务分为读取、创建、编辑三大类（基于用户意图），然后针对每一类提供各自的操作选项。这种分层设计避免了将所有可能场景堆叠在一起导致的混乱，使指令结构清晰、逻辑分明。

决策树模式的另一个优点是它隐含了优先级信息。当用户表达的需求模糊或多义时，决策树提供了明确的歧义消除路径。例如，当用户说「修改这个文档」时，Claude 需要判断这是「简单修改」还是需要「修订追踪」的复杂修改，决策树中的条件判断指引 Claude 进一步询问或根据上下文推断。

### 3.2 强制前置条件模式

在关键操作前，技能使用了「MANDATORY」标记来强调前置条件的必要性。这种模式在文档创建和编辑的指令中反复出现：

```markdown
**MANDATORY - READ ENTIRE FILE**: Read [`docx-js.md`](url) (~500 lines) completely from start to finish. **NEVER set any range limits when reading this file.** Read the full file content for detailed syntax, critical formatting rules, and best practices before proceeding with document creation.
```

强制前置条件模式的设计基于对 AI 执行特点的理解。AI 在执行复杂任务时可能「急于求成」，跳过重要的准备工作步骤。通过明确标记「MANDATORY」，指令确保 Claude 在执行关键操作前已经完成了必要的知识准备。

「NEVER set any range limits」这种否定式指令是对 AI 读取文件行为的精确控制。在之前的实践中，AI 可能为了效率而只读取文件的部分内容，导致遗漏关键信息。这种否定式指令明确禁止了这种行为，确保 Claude 获取完整的上下文。

### 3.3 批次执行模式

对于需要大量重复操作的任务，技能引入了批次执行（Batch Execution）模式。修订追踪工作流是这一模式的典型应用场景。当需要对文档进行大量修改时，指令建议将变更分组为 3-10 个变更的小批次，然后逐批次执行。

批次执行模式的优点可以从多个角度理解：

**可调试性**：小批次的变更更容易追踪和回溯。当某个批次出现问题时，可以快速定位并修复，而不需要在大量变更中排查。

**增量验证**：每个批次完成后可以立即验证结果，确保变更符合预期。这种增量式的方法比一次性应用所有变更更加可靠。

**心理可管理性**：对于人类操作者来说，面对大量变更会产生压力和焦虑。批次划分将大任务分解为可管理的小任务，降低了认知负担。

指令中还提供了批次组织的具体建议：可以按文档章节、按变更类型、按复杂程度或按页面顺序进行分组。这种灵活性允许用户根据自己的需求选择最适合的分组方式。

### 3.4 对比示例模式

技能指令中大量使用对比示例（Contrasting Examples）来展示正确和错误的做法。这种模式特别适用于代码生成和格式处理场景，因为这些场景中正确的实现往往与直觉相悖。

对比示例的优势在于其直观性。Claude 可以直接「看到」预期输出和错误输出的区别，而不需要从抽象描述中推断正确做法。DOCX 技能中关于修订追踪的代码示例是这一模式的优秀示范：

```markdown
# BAD - Replaces entire sentence
'The term is 30 days.The term is 60 days.'

# GOOD - Only marks what changed, preserves original <w:r> for unchanged text
'The term is <w:del>30</w:del><w:ins>60</w:ins> days.'
```

标签（BAD/GOOD）的使用进一步强化了对比效果，使 Claude 能够明确识别出推荐的做法。

### 3.5 工具链文档引用模式

对于复杂的技术操作，技能采用了「核心指令 + 详细参考文档」的双层结构。核心 SKILL.md 文件包含任务决策和工作流程的指令，而具体的工具使用方法、API 参考等详细文档则通过引用外部文件提供。

这种模式的典型应用是 DOCX 技能中的文档编辑指令。核心指令只描述工作流程（解压、编辑、打包），而将 Document 库的具体 API 和 XML 操作细节留给 ooxml.md 文件（约 600 行）。指令同样使用了 MANDATORY 标记要求完整阅读参考文档。

双层结构的优点是平衡了简洁性和完整性。核心指令保持简短，便于快速理解和遵循；详细参考文档提供深度信息，供需要时查阅。这种设计也便于参考文档的独立更新——当工具 API 发生变化时，只需要更新参考文档，而核心指令结构保持稳定。

## 四、变量与模板处理

### 4.1 元数据变量

技能中的 YAML 前置元数据定义了可在技能内使用的变量。name 字段定义技能标识符，description 字段定义技能描述和应用场景。这些元数据不仅用于技能管理和匹配，在技能执行时也可能被引用。

元数据的设计体现了声明式配置的理念。通过声明式的元数据定义，技能的意图被明确表达，便于 Claude 理解和用户维护。与命令式配置相比，声明式配置更易于理解、验证和修改。

### 4.2 文档结构模板

文档处理技能中隐含了文档结构的模板概念。以 DOCX 技能为例，创建新文档需要使用特定的组件结构：

```markdown
Create a JavaScript/TypeScript file using Document, Paragraph, TextRun components
```

这种组件化的文档构建方式本身就是一种模板模式。用户需要遵循特定的组件组合方式来构建文档，而不是直接操作底层 XML。这种抽象层次的设计使得文档创建更加直观和安全，减少了因 XML 操作错误导致的格式问题。

### 4.3 脚本模板

技能目录中的 scripts 目录包含了可复用的脚本模板。DOCX 技能提供了 unpack.py 和 pack.py 两个脚本，分别用于解压 DOCX 文件和重新打包。脚本的设计是可复用的——用户只需要提供输入输出路径，脚本处理具体的技术细节。

```bash
# 解压脚本使用
python ooxml/scripts/unpack.py <path-to-file.docx>

# 打包脚本使用
python ooxml/scripts/pack.py <unpacked-dir> <output-file.docx>
```

这种脚本模板的设计使得复杂的技术操作对用户透明，用户不需要理解 DOCX 的内部结构或 XML 操作细节，只需遵循简单的命令行接口。

### 4.4 提示词模板

技能指令本身可以被视为一种「提示词模板」。以修订追踪工作流为例，指令定义了一个可复用的流程模板：

1. 获取 Markdown 表示
2. 识别和分组变更
3. 阅读文档并解压
4. 逐批次实现变更
5. 打包文档
6. 最终验证

这个模板可以应用于任何需要修订追踪的场景，只需要将具体的变更内容填充到模板中。模板的复用性使得复杂工作流程能够被一致地执行。

## 五、提示词优化建议

### 5.1 增强错误处理指导

当前技能指令中的错误处理指导相对分散，建议在关键决策点增加明确的异常处理指南。例如，在解压、打包等文件操作步骤中，可以明确说明常见错误类型（文件不存在、权限不足、格式损坏等）的处理方式。

优化后的错误处理部分可以包含：

```markdown
### 常见错误处理

**文件不存在错误**：在执行解压或打包操作前，使用 `ls` 或 `test -f` 命令验证文件路径正确性。如果文件不存在，提示用户提供正确路径。

**权限错误**：如果遇到权限拒绝错误，检查目标目录的写权限。需要时使用 `chmod` 调整权限或选择其他输出路径。

**格式损坏错误**：如果解压或打包过程中出现 XML 解析错误，文档可能已损坏。尝试使用备份文件或要求用户提供未损坏的版本。
```

### 5.2 增加交互式确认机制

对于不可逆的操作（如覆盖文件、批量修改），建议增加交互式确认机制。当前指令假设 Claude 能够正确判断何时需要确认，但更明确的指导可以减少意外发生。

建议在关键操作前添加确认步骤的模板：

```markdown
### 操作确认

在执行以下操作前，应向用户确认：

1. **覆盖现有文件**：询问用户是否确认覆盖目标文件
2. **批量应用变更**：在应用变更批次前，展示即将进行的变更摘要并请求确认
3. **最终完成**：在打包最终文档前，确认用户对所有变更满意

确认模板：
"我将执行以下操作：[操作描述]。请确认是否继续？(yes/no)"
```

### 5.3 完善性能优化指导

对于大规模文档处理场景，建议增加性能优化指导。当前指令关注正确性，但在大文件处理时，性能考虑也很重要。

建议增加的性能优化点包括：

```markdown
### 性能优化建议

**大文件处理**：对于超过 50 页的文档，建议增加处理过程中的内存释放步骤。在完成每个批次的变更后，关闭并重新打开文档对象以释放内存。

**批量脚本优化**：对于需要进行大量相似操作的情况，考虑使用批量处理脚本而非循环调用单次操作。Python 的列表推导式和批量 DOM 操作可以显著减少执行时间。

**并行处理考虑**：如果任务可以分解为相互独立的子任务（如处理多个独立文档），考虑使用 `concurrent.futures.ThreadPoolExecutor` 实现并行处理。
```

### 5.4 增强跨技能协作指导

当任务需要多个技能协作时，当前的指令缺乏明确的协作指导。建议增加跨技能协作的最佳实践，帮助 Claude 在需要时正确组合多个技能。

建议增加的协作指导：

```markdown
### 跨技能协作

当任务涉及多个技能领域时，应遵循以下原则：

1. **识别主导技能**：确定任务的主要领域，选择该领域的技能作为主导
2. **顺序应用技能**：按照逻辑顺序应用不同技能，通常先完成结构或内容处理，再进行格式和样式调整
3. **技能切换声明**：当从一个技能的上下文切换到另一个技能时，明确声明当前技能名称和切换原因
4. **结果传递**：在技能之间传递中间结果时，确保格式兼容和内容完整
```

### 5.5 增加可观测性设计

建议在技能指令中增加执行过程的日志和可观测性设计。这有助于问题诊断和流程追踪，特别是在处理复杂文档时。

建议增加的内容：

```markdown
### 执行追踪

对于复杂任务，建议记录关键步骤的执行状态：

**步骤日志**：在每个主要步骤开始和结束时，记录当前状态和关键参数
```python
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

logger.info(f"Starting batch {batch_num} with {len(changes)} changes")
# ... 执行变更 ...
logger.info(f"Completed batch {batch_num}")
```

**检查点保存**：在完成重要里程碑后，保存中间结果作为检查点
```bash
# 在每个批次完成后保存中间状态
cp reviewed-document.docx checkedpoints/batch-${batch_num}.docx
```

**问题诊断**：当出现问题时，利用检查点快速回滚到稳定状态
```

### 5.6 标准化测试用例

建议为每个技能增加标准化测试用例的定义，确保技能在不同输入下表现一致。测试用例可以作为技能质量的验证标准，也可以作为新技能开发的参考。

建议的测试用例结构：

```markdown
## 测试用例

### 基础功能测试

| 测试场景 | 输入 | 预期输出 | 验证方法 |
|---------|-----|---------|---------|
| 简单文档创建 | 空文档 | 格式正确的 .docx 文件 | 使用 Word 打开验证 |
| 文本替换 | 包含特定文本的文档 | 文本被正确替换 | 使用 pandoc 提取文本验证 |

### 边界情况测试

| 测试场景 | 输入 | 预期行为 |
|---------|-----|---------|
| 空文档 | 空 .docx 文件 | 正确处理，不报错 |
| 特殊字符 | 包含 emoji、数学符号的文本 | 正确保留，不乱码 |
| 大文档 | 超过 100 页的文档 | 正确处理，性能可接受 |
```

---

## 六、总结

### 6.1 设计亮点总结

Anthropic Skills 项目展示了高质量提示词工程的最佳实践。其设计亮点包括：清晰的决策树结构指导任务分解；强制前置条件确保关键步骤不被跳过；批次执行模式平衡效率与可维护性；对比示例提供直观的正确做法指导；双层文档结构平衡简洁性与完整性。这些设计模式共同构成了一个可维护、可扩展、高质量的提示词系统。

### 6.2 可借鉴的设计原则

从 Skills 项目中可以提炼出以下可借鉴的提示词设计原则：

**结构化指令**：将复杂任务分解为清晰的层级结构，使用决策树引导执行路径。

**明确边界**：通过详细的适用场景描述和不适用场景说明，定义技能的使用边界。

**强制检查点**：在关键步骤前使用「MANDATORY」标记，确保前置条件被满足。

**可复用模式**：将重复出现的工作流程抽象为可复用的模板和脚本。

**渐进式细节**：采用「核心指令 + 参考文档」的双层结构，平衡简洁性与完整性。

**可视化对比**：使用正反对比例示直观展示预期行为。

这些原则适用于任何需要构建高质量提示词的场景，无论是 AI 助手、技能系统还是自动化流程。
