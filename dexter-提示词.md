# Dexter 提示词分析文档

本文档深入分析 Dexter 项目中的提示词（Prompt）设计，包括提示词的位置分布、完整内容，设计模式、变量模板以及优化建议。通过这些分析，开发者可以理解项目的提示词工程实践，并在需要时进行定制和扩展。

## 1. 提示词位置与文件结构

### 1.1 核心提示词文件

Dext核心的提示词逻辑集中在 `src/agent/prompts.ts` 文件中，该文件包含了系统提示词的构建逻辑、用户提示词的模板以及辅助函数。这个文件是理解 Dexter 提示词工程的核心入口点，项目的其他文件都通过调用其中的函数来获取提示词内容。

`src/agent/prompts.ts` 文件导出了四个主要的提示词相关函数和常量。第一个是 `DEFAULT_SYSTEM_PROMPT`，这是用于向后兼容的默认系统提示词，当没有特殊配置时会使用这个基础提示词。第二个是 `getCurrentDate()` 函数，返回格式化的当前日期，用于提示词中的时间参考。第三个是 `buildSystemPrompt(model: string)` 函数，这是构建完整系统提示词的主要函数，会根据传入的模型名称动态生成包含工具描述和技能信息的系统提示词。第四个是 `buildIterationPrompt(originalQuery: string, fullToolResults: string, toolUsageStatus?: string | null)` 函数，用于构建迭代过程中的用户提示词。第五个是 `buildFinalAnswerPrompt(originalQuery: string, fullContextData: string)` 函数，用于构建最终答案生成阶段的提示词。

### 1.2 工具描述文件位置

工具的详细描述信息存储在 `src/tools/descriptions/` 目录下，每个工具都有独立的描述文件。这些描述文件使用了丰富的结构化格式，包含工具的用途说明、使用时机、禁止使用场景、参数说明等详细信息。工具描述文件包括：`financial-search.ts` 定义了财务搜索工具的描述、`financial-metrics.ts` 定义了财务指标工具的描述、`read-filings.ts` 定义了 SEC 文件阅读工具的描述、`web-search.ts` 定义了网页搜索工具的描述、`browser.ts` 定义了浏览器工具的描述。

工具注册表 `src/tools/registry.ts` 负责加载这些描述文件并构建系统提示词中的工具描述部分。注册表中的 `buildToolDescriptions(model: string)` 函数会将所有注册工具的描述格式化为系统提示词的一部分。这种设计将工具的业务逻辑与描述信息分离，便于维护和更新。

### 1.3 技能描述文件位置

技能系统的描述信息存储在 `src/skills/` 目录下，采用 `SKILL.md` 文件格式。每个技能文件包含两部分内容：YAML 前言部分定义技能的元数据（如名称、描述），Markdown 主体部分定义技能的执行指令。技能发现器 `src/skills/index.ts` 负责扫描和加载这些技能文件，并生成技能元数据部分供提示词使用。

技能描述在运行时动态插入到系统提示词中，只有当技能被发现器扫描到并成功加载后，相关的元数据才会被包含在系统提示词里。这种设计使得添加新技能只需创建对应的 `SKILL.md` 文件，无需修改核心提示词代码。

## 2. 提示词完整内容分析

### 2.1 默认系统提示词

默认系统提示词 `DEFAULT_SYSTEM_PROMPT` 是项目早期版本的遗留设计，用于向后兼容场景。以下是完整的提示词内容：

```
You are Dexter, a helpful AI assistant.

Current date: {current_date}

Your output is displayed on a command line interface. Keep responses short and concise.

## Behavior

- Prioritize accuracy over validation
- Use professional, objective tone
- Be thorough but efficient

## Response Format

- Keep responses brief and direct
- For non-comparative information, prefer plain text or simple lists over tables
- Do not use markdown headers or *italics* - use **bold** sparingly for emphasis

## Tables (for comparative/tabular data)

Use markdown tables. They will be rendered as formatted box tables.

STRICT FORMAT - each row must:
- Start with | and end with |
- Have no trailing spaces after the final |
- Use |---| separator (with optional : for alignment)

| Ticker | Rev    | OM  |
|--------|--------|-----|
| AAPL   | 416.2B | 31% |

Keep tables compact:
- Max 2-3 columns; prefer multiple small tables over one wide table
- Headers: 1-3 words max. "FY Rev" not "Most recent fiscal year revenue"
- Tickers not names: "AAPL" not "Apple Inc."
- Abbreviate: Rev, Op Inc, Net Inc, OCF, FCF, GM, OM, EPS
- Numbers compact: 102.5B not $102,466,000,000
- Omit units in cells if header has them
```

这个默认提示词虽然简短，但已经建立了几个重要的约定：角色定义为 CLI 助手、输出风格要求简洁专业、表格格式有严格规范、以及数字和缩写的使用规则。

### 2.2 完整系统提示词构建逻辑

`buildSystemPrompt()` 函数是构建生产环境系统提示词的核心函数。该函数会组装五个主要部分：角色定义与当前日期、可用工具描述与使用规则、技能元数据（如果可用）、行为准则、响应格式规范。以下是该函数生成的完整提示词结构分析：

第一部分是角色定义和日期信息，明确 Agent 的身份是「Dexter，一个带有研究工具的 CLI 助手」，并标注当前日期以便 LLM 进行时效性判断。第二部分是可用工具部分，这是提示词的核心内容，通过调用 `buildToolDescriptions(model)` 生成。第三部分是工具使用政策，明确规定何时使用工具、何时直接回答、如何组合工具调用等规则。第四部分是技能元数据部分（如果发现可用技能），包含技能列表和使用政策。第五部分是行为准则，强调准确性优先，专业客观、避免过度工程化等原则。第六部分是响应格式规范，定义了如何格式化输出内容，特别是针对表格数据提供了详细的格式要求。

### 2.3 迭代提示词模板

`buildIterationPrompt()` 函数用于构建 Agent 迭代过程中的用户提示词。这个提示词在每次 LLM 调用时都会被重新组装，传递给 LLM 进行下一轮推理。模板结构如下：

```
Query: {original_query}

Data retrieved from tool calls:
{full_tool_results}

{tool_usage_status}

Continue working toward answering the query. If you gathered actual content (not just links or titles), you may respond. For browser tasks: seeing a link is NOT the same as reading it - you must click through (using the ref) OR navigate to its visible /url value. NEVER guess at URLs - use ONLY URLs visible in snapshots.
```

这个模板的设计体现了几个关键原则：首先明确原始查询，让 LLM 始终聚焦于用户的核心问题；其次展示已收集的数据，让 LLM 基于事实进行推理；然后可选地包含工具使用状态，用于优雅退出机制；最后给出明确的行动指示。

### 2.4 最终答案提示词模板

`buildFinalAnswerPrompt()` 函数用于构建最终答案生成阶段的提示词。与迭代提示词不同，这个提示词在 Agent 完成所有工具调用后使用，此时系统会从草稿板加载完整的上下文数据。模板结构如下：

```
Query: {original_query}

Data retrieved from your tool calls:
{full_context_data}

Answer the user's query using this data. Do not ask the user to provide additional data, paste values, or reference JSON/API internals. If data is incomplete, answer with what you have.
```

这个模板的设计重点在于：强调使用收集到的数据来回答问题、禁止要求用户提供额外数据、禁止暴露 JSON 或 API 内部实现细节、如果数据不完整则基于已有信息回答。这种设计确保了最终输出的用户友好性，避免了技术细节的泄露。

## 3. 提示词设计模式详解

### 3.1 信息渐进披露模式

Dext提示词系统采用了信息渐进披露（Progressive Disclosure）的设计模式。这种模式的核心思想是将不同类型的信息按照重要性和使用频率进行分层组织，使得 LLM 能够在不同阶段获取最相关的信息。

在系统提示词层面，核心指令（角色定义、行为准则）始终可见，但工具描述部分可能会根据模型配置进行调整。在用户提示词层面，随着迭代的进行，上下文信息会逐步积累，但 LLM 始终能够看到原始查询和最新收集的数据。当上下文超出阈值时，最早的工具调用结果会被清理，但 LLM 可以通过工具使用状态了解完整的执行历史。

这种设计的优势在于：既能保证 LLM 始终拥有足够的上下文信息来进行推理，又能有效控制 Token 消耗。同时，清晰的层级结构也使得提示词易于维护和扩展。

### 3.2 工具使用策略模式

工具使用策略是 Dexter 提示词设计中最复杂的部分之一。系统通过详细的策略说明，指导 LLM 何时使用工具、如何使用工具、以及如何避免常见错误。

以下是工具使用策略的核心规则体系：

**何时使用工具规则**明确了三类场景：必须使用工具的场景（如实时财务数据、公司信息查询）、不应使用工具的场景（如概念性定义，稳定的历史事实、对话性查询）、以及判断标准（如果查询涉及具体公司，人员或组织的当前状态，应该使用工具验证）。

**如何调用工具规则**定义了具体的操作规范：优先使用 financial_search 而非 web_search 处理财务数据、一次调用包含完整的自然语言查询而非拆分为多个调用、对于事实性问题使用工具验证而非直接回答。

**浏览器工具特殊规则**解决了 LLM 在处理网页内容时的常见问题：链接不等于已阅读，必须点击访问或导航到实际 URL、禁止猜测 URL，只能使用快照中可见的 URL、收集实际内容而非仅获取链接和标题。

这些策略规则的编写遵循了「具体化」原则，每个规则都有明确的适用场景和操作指南，便于 LLM 理解和遵循。

### 3.3 输出格式规范化模式

Dext提示词系统对 LLM 的输出格式进行了严格的规范化定义，这种设计确保了最终输出的一致性和可读性，特别是在处理表格数据时。

**普通文本格式规范**定义了日常对话的格式要求：保持简洁直接、优先使用纯文本或简单列表而非表格、避免使用 Markdown 标题和斜体，粗体仅用于重点强调。

**表格格式规范**是提示词中最为详细的部分，定义了六个严格的格式要求：

第一，行格式要求：每行必须以竖线开头和结尾、最终竖线后不能有空格、使用竖线和短横线组合作为分隔符（可选择添加冒号进行对齐）。

第二，紧凑性要求：每列数量限制在两到三列、优先使用多个小表格而非一个宽表格、避免在单行中塞入过多信息。

第三，标题要求：标题词汇数限制在一到三个单词、使用缩写而非完整描述（如「FY Rev」而非「Most recent fiscal year revenue」）。

第四，标识符要求：使用股票代码而非公司全称（如「AAPL」而非「Apple Inc.」）、便于快速识别和比对。

第五，数值格式要求：使用缩写表示大数字（如「102.5B」而非「$102,466,000,000」）、保持数值的简洁性和可读性。

第六，单位处理要求：如果表头已包含单位，则单元格中省略单位、避免单位重复造成的视觉混乱。

这种严格的格式规范设计，确保了 LLM 输出的表格能够在 CLI 界面中被正确渲染，提供了良好的用户体验。

### 3.4 上下文管理提示词模式

上下文管理是 Agent 系统中的关键挑战。Dext提示词系统采用了多种策略来帮助 LLM 有效管理上下文。

**完整结果保留策略**（Anthropic 风格）要求在迭代过程中保持完整工具结果在上下文中，不进行内联摘要，而是让 LLM 直接访问原始数据。这种设计避免了信息压缩带来的精度损失，同时简化了系统实现。

**阈值清理触发策略**定义了当上下文超出 Token 阈值时的处理方式：系统自动清理最早的 K 个工具调用结果、LLM 通过工具使用状态了解哪些调用已被清理、清理后重新构建迭代提示词。

**最终答案上下文重建策略**解决了清理后可能丢失信息的问题：在生成最终答案时，系统从草稿板（持久化存储）加载完整的上下文数据，确保最终答案能够基于所有收集的信息生成。

## 4. 变量与模板系统

### 4.1 系统提示词变量

系统提示词中的变量在构建时动态替换，主要包括以下几类：

`{current_date}` 变量通过 `getCurrentDate()` 函数生成，返回格式化的当前日期。格式采用「完整星期几、完整月份、日期、年份」的形式，如「Monday, January 6, 2025」。这个日期信息对于 LLM 进行时效性判断至关重要，特别是在处理财务数据时，LLM 需要知道当前日期才能正确解读数据的时效性。

`{model}` 变量代表当前使用的模型名称，由 `buildSystemPrompt()` 函数的参数传入。这个变量用于工具描述的生成，不同的模型可能需要不同的工具集配置（尽管当前版本中工具集不随模型变化）。

`{tool_descriptions}` 变量是最大的动态内容部分，由 `buildToolDescriptions()` 函数生成。该函数查询工具注册表，将所有注册工具的描述格式化为 Markdown 列表。工具描述包括工具名称、详细功能说明、使用示例、参数定义等信息。

`{skill_metadata}` 变量（条件性存在）包含发现的所有技能的元数据，只有当技能发现器检测到可用技能时才会生成这个部分。技能元数据包括技能名称、描述、以及通过 `skill` 工具调用技能的说明。

### 4.2 用户提示词变量

用户提示词中的变量与用户的交互过程直接相关：

`{original_query}` 变量保存用户的原始问题，这个变量在迭代过程中始终保持不变，确保 LLM 始终聚焦于用户的核心需求。无论上下文如何变化，原始查询始终作为参考点。

`{full_tool_results}` 变量包含所有已收集的工具调用结果。这些结果来自草稿板管理模块，经过格式化处理后嵌入到迭代提示词中。当上下文清理发生时，这个变量的内容会相应更新。

`{tool_usage_status}` 变量（可选）包含工具调用的统计信息，如已执行的调用次数、每个工具的调用频率等。这个信息主要用于优雅退出机制，帮助 LLM 了解是否应该继续调用工具或准备生成最终答案。

`{full_context_data}` 变量（仅最终答案阶段）包含从草稿板持久化存储加载的完整上下文数据。与迭代提示词中的 `full_tool_results` 不同，这个变量在最终答案阶段包含所有历史调用结果，即使某些早期调用已被清理出内存。

### 4.3 模板组合逻辑

提示词模板的组合遵循明确的执行流程：

在 Agent 创建阶段，`buildSystemPrompt()` 被调用一次，生成并缓存系统提示词。这个提示词在后续的每次 LLM 调用中都会使用。

在每次迭代开始时，`buildIterationPrompt()` 被调用，组装当前迭代的用户提示词。这个函数接收当前的上下文状态作为参数，动态生成提示词内容。

在最终答案生成阶段，`buildFinalAnswerPrompt()` 被调用，从草稿板加载完整上下文后组装最终提示词。

这种分层设计确保了提示词的高效构建，避免了重复计算同一部分内容。

## 5. 工具描述内容详解

### 5.1 财务搜索工具描述

`financial_search` 是 Dexter 中最重要的工具，其描述信息经过精心设计，以指导 LLM 正确使用这个多功能工具。描述内容包括以下几个核心组成部分：

**功能概述**定义了这个工具的核心能力：这是一个统一的财务数据搜索接口，能够同时处理多公司、多指标的查询请求。LLM 应该将复杂的财务分析需求直接表达为自然语言查询，而无需拆分为多个独立调用。

**使用时机**明确了何时应该使用这个工具：查询股票价格历史、获取财务指标数据、搜索 SEC 文件信息、查找内部交易记录、获取公司基本信息、以及其他涉及实时或历史财务数据的场景。

**禁止使用场景**定义了不应使用这个工具的情况：非财务相关的一般性搜索应该使用 web_search、概念性定义或基础知识问答应该直接回答、对话性查询或闲聊应该直接回应。

**查询构造指导**提供了如何构建有效查询的建议：可以一次性询问多家公司的数据（如「苹果、微软、谷歌的营收对比」）、可以同时请求多个指标（如「特斯拉最近四季度的营收、净利润和现金流」）、使用自然语言表达复杂的分析需求。

### 5.2 财务指标工具描述

`financial_metrics` 工具提供了更细粒度的财务数据访问能力。描述内容包括：

**功能定义**说明这个工具专门用于获取特定财务指标，支持按公司、指标类型、时间周期等维度进行筛选。适用于需要深入分析特定财务维度的场景。

**参数说明**定义了工具接受的参数结构：公司代码（必填）、指标类型（可选）、时间周期（可选，默认为最近期间）、数据限制（可选）。

**结果解读**指导 LLM 如何解释工具返回的结果：返回的 JSON 格式包含指标名称、数值，时间戳等信息、LLM 应该提取关键数据点而非直接展示原始 JSON、可以进一步调用其他工具进行交叉验证。

### 5.3 SEC 文件阅读工具描述

`read_filings` 工具用于访问 SEC（美国证券交易委员会）的官方文件。描述内容包括：

**功能概述**说明这个工具能够获取和解析 SEC 的各类文件，包括 10-K（年度报告）、10-Q（季报）、8-K（重大事项公告）、以及 S-1/S-3（招股说明书）等。

**使用场景**定义了适合使用这个工具的情况：分析公司的年度报告以了解业务全貌、查看季报中的管理层讨论和分析、追踪重大事项公告中的公司动态、研究招股说明书以了解公司的历史和风险因素。

**结果处理**指导 LLM 如何处理 SEC 文件的内容：文件通常是长文本，LLM 应该总结关键信息而非逐字引用、关注风险披露、重要财务数据，管理层的关键变动等关键内容、可以将文件内容作为进一步分析的输入。

### 5.4 网页搜索工具描述

`web_search` 工具作为财务搜索的补充，提供一般性网页搜索能力。描述内容包括：

**功能定位**说明这个工具用于财务搜索无法覆盖的场景，如公司新闻、行业分析、市场动态等。

**优先级规则**定义了搜索引擎的选择优先级：优先使用 Exa（如果配置了 `EXASEARCH_API_KEY`），Exa 提供更高质量的搜索结果；否则回退到 Tavily。

**使用限制**明确了这个工具的适用范围：不应该用于可以通过 financial_search 获取的财务数据、对于需要实时新闻或最新市场动态的查询可以使用这个工具。

### 5.5 浏览器工具描述

`browser` 工具基于 Playwright 实现，能够访问和抓取网页内容。描述内容强调了以下关键点：

**核心能力**说明这个工具可以执行网页导航、点击链接、滚动页面、截取内容等操作。

**使用时机**定义了何时应该使用浏览器工具：需要阅读搜索结果中发现的文章或页面、需要访问公司官网获取特定信息、需要抓取结构化数据无法覆盖的信息。

**重要规则**明确了一个常见误区的解决方案：仅仅看到链接不等于已经阅读了内容，必须点击访问或导航到实际 URL；禁止猜测 URL，只能使用快照中可见的 URL。

### 5.6 技能工具描述

`skill` 工具用于调用预定义的分析工作流程。描述内容包括：

**功能定义**说明技能是一系列预定义的分析步骤，可以自动执行复杂的多阶段分析任务。

**可用技能**（条件性显示）列出当前已发现的技能列表及其描述，如 DCF（折现现金流）估值分析等。

**使用规则**定义了技能调用的限制：每个技能在单次查询中只能执行一次、LLM 应该判断哪个技能适合当前任务，并在适当时机调用。

## 6. 提示词优化建议

### 6.1 工具描述优化

当前的工具描述虽然详细，但仍有改进空间。以下是具体的优化建议：

**示例增强**：在每个工具描述中增加具体的查询示例。例如，在 financial_search 描述中增加「示例1：比较苹果和微软最近三年的营收增长率；示例2：获取英伟达过去6个月的股价数据并计算波动率」等示例。这些示例能够帮助 LLM 更好地理解工具的使用方式和边界。

**错误处理指导**：当前工具描述缺少错误处理指导。建议增加关于如何处理工具调用失败的说明。例如，当财务数据 API 返回错误时，LLM 应该尝试替代数据源或向用户说明问题。

**数据新鲜度指导**：对于不同类型的数据，建议增加关于数据新鲜度和更新频率的说明。例如，股价数据通常是实时的，而 SEC 文件可能有几天的延迟。

### 6.2 响应格式优化

当前响应格式规范已经相当完善，但可以考虑以下增强：

**错误响应格式**：定义当出现问题或无法回答时的标准响应格式，帮助 LLM 在遇到困难时能够优雅地处理。

**置信度表达**：增加关于如何表达信息置信度的指导。例如，当数据不完整或存在不确定性时，LLM 应该明确标注。

**多语言支持**：如果计划支持中文查询，可以考虑增加中文输出格式的专门规范。

### 6.3 上下文管理优化

**渐进式摘要**：当前系统在上下文超限时直接清理最早的结果。可以考虑在清理前生成摘要，保留关键洞察而非完全丢弃早期结果。

**查询依赖追踪**：增加工具调用之间的依赖关系记录。当清理早期结果时，如果后续调用依赖于前置结果，系统可以自动触发重新调用。

**选择性上下文**：对于长文档（如 SEC 10-K 文件），可以设计选择性加载机制，只在需要时加载相关章节，而非加载完整文档。

### 6.4 技能系统优化

**技能选择指导**：增加更详细的技能选择指导，帮助 LLM 判断何时应该使用技能，以及如何组合多个技能。

**技能输出规范化**：定义技能输出的标准格式，确保不同技能的输出可以被后续步骤正确处理。

**技能参数验证**：在技能工具描述中增加参数验证的说明，帮助 LLM 在调用技能前进行参数检查。

### 6.5 成本优化策略

**Token 使用可视化**：考虑在提示词中增加 Token 使用概览，帮助 LLM 有意识地控制响应长度。

**缓存利用指导**：利用 Anthropic 的提示词缓存功能（已实现），在提示词中标注哪些内容适合缓存。

**批量处理建议**：在工具使用策略中增加批量处理的建议，避免不必要的重复调用。

## 7. 提示词版本与兼容性

### 7.1 版本管理策略

Dext提示词系统采用了版本化的管理策略，通过 `buildSystemPrompt()` 函数统一管理提示词版本。当前版本号隐含在代码版本中（`package.json` 中的 version 字段），但提示词本身没有独立的版本标识。

建议的改进是在提示词构建函数中显式包含版本信息，例如在系统提示词末尾添加版本注释。这样做的好处包括：便于追踪提示词变更历史、支持不同版本提示词的对比测试、有助于用户报告问题时的定位。

### 7.2 向后兼容性

`DEFAULT_SYSTEM_PROMPT` 常量的存在体现了项目对向后兼容性的关注。当新版本的 `buildSystemPrompt()` 发生变化时，这个默认提示词作为降级方案仍然可用。

兼容性的另一个方面是工具描述的稳定性。当新增或修改工具描述时，需要考虑对 Agent 行为的影响。建议在工具描述变更时同步更新评估数据集，确保系统行为的一致性。

### 7.3 提示词测试

项目当前缺少专门的提示词测试套件。建议增加以下测试场景：

**单元测试**：测试 `buildSystemPrompt()` 的输出格式正确性、变量替换的完整性、以及条件分支的覆盖。

**集成测试**：使用评估数据集测试不同提示词版本对 Agent 行为的影响。

**A/B 测试**：在生产环境中对比不同提示词版本的效果，收集真实用户的反馈数据。

## 总结

Dext提示词系统体现了成熟的提示词工程实践，包括信息渐进披露、详细的工具使用策略、规范化的输出格式、以及有效的上下文管理。系统通过结构化的设计，实现了复杂金融研究任务的自动化执行。

理解这些提示词的设计原则和实现细节，对于贡献代码、定制功能、或扩展新能力都至关重要。建议在修改提示词时遵循以下原则：保持风格的一致性、增加而非减少清晰度、通过测试验证改动的影响、以及在文档中记录重要的设计决策。